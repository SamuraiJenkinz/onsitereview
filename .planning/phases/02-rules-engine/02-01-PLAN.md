# Plan 02-01: Rules Engine

## Objective
Implement deterministic evaluation rules that handle ~40% of ticket scoring. These rules can be evaluated without LLM calls, providing fast, consistent scoring for format validation, pattern detection, and process compliance.

## Prerequisites
- Phase 1 complete (models, parser working)
- Understanding of scoring rubrics (scoring_rubrics.json)
- Sample tickets available for testing

## Rules Overview

Based on the scoring rubrics, the following criteria can be evaluated with rules:

| Criterion | Max Points | Evaluation Type | Notes |
|-----------|------------|-----------------|-------|
| Short Description Format | 8 | Rules | 4-part format validation |
| Validation Detection | PASS/-15/FAIL | Rules | Pattern matching in description |
| Critical Process Detection | PASS/-35/FAIL | Rules | Keyword detection + process check |
| Category | 10 | Hybrid | Basic validation (rules) + accuracy (LLM) |
| Subcategory | 10 | Hybrid | Basic validation (rules) + accuracy (LLM) |
| Service | 10 | Hybrid | Basic validation (rules) + accuracy (LLM) |
| Configuration Item | 10 | Hybrid | Basic validation (rules) + accuracy (LLM) |

## Tasks

### Task 1: Rules Engine Module Structure
**Create the rules package structure**

Create:
```
src/tqrs/rules/
    __init__.py
    base.py              # Base classes and types
    short_description.py # 4-part format validator
    validation.py        # Validation pattern detector
    critical_process.py  # Critical process detector
    evaluator.py         # Orchestrates all rules
```

Define base types in `base.py`:
```python
class RuleResult(BaseModel):
    """Result from a single rule evaluation."""
    criterion_id: str
    passed: bool
    score: int | str  # Can be numeric or PASS/FAIL/N/A
    evidence: str
    reasoning: str
    coaching: str | None = None

class RuleEvaluator(Protocol):
    """Protocol for rule evaluators."""
    def evaluate(self, ticket: ServiceNowTicket) -> RuleResult: ...
```

**Verification**:
- [ ] Package imports correctly
- [ ] Base types defined with proper typing
- [ ] `from tqrs.rules import RulesEngine` works

---

### Task 2: Short Description Validator
**Validate 4-part format: [LoB] - [Location] - [App] - [Brief]**

Create `src/tqrs/rules/short_description.py`:

```python
class ShortDescriptionValidator:
    """Validate short description follows 4-part format."""

    # Known LoB prefixes
    LOB_PATTERNS = ["MARSH", "MERCER", "MMC", "MMC-NCL", "GC", "OW", ...]

    # Common location patterns (cities, offices)
    LOCATION_PATTERNS = [regex patterns for cities/locations]

    # Common application names
    APP_PATTERNS = ["VDI", "LAN", "AD", "Outlook", "Teams", ...]

    def validate(self, ticket: ServiceNowTicket) -> RuleResult:
        """Validate short description format."""
        parts = self._parse_parts(ticket.short_description)
        issues = self._check_parts(parts, ticket)
        score = self._calculate_score(issues)
        return RuleResult(...)

    def _parse_parts(self, desc: str) -> dict:
        """Parse short description into 4 parts."""
        # Handle both " - " and "-" separators
        # Return dict with lob, location, app, brief

    def _check_parts(self, parts: dict, ticket: ServiceNowTicket) -> list[str]:
        """Check each part for issues."""
        # Verify LoB matches known patterns or ticket flags
        # Verify location is present and reasonable
        # Verify app/system is present
        # Verify brief description is concise
```

Scoring logic:
- 8 points: All 4 parts correct and accurate
- 6 points: 1 item incorrect/missing
- 4 points: 2 items incorrect/missing
- 2 points: 3 items incorrect/missing
- 0 points: 4 items incorrect/missing

**Verification**:
- [ ] Correctly parses "MMC-NCL Bangalore-VDI-error message" → 4 parts
- [ ] Correctly parses "Marsh - Mumbai - LAN - Need password reset" → 4 parts
- [ ] Identifies missing/incorrect parts
- [ ] Returns appropriate score and coaching

---

### Task 3: Validation Pattern Detector
**Detect validation documentation in ticket description**

Create `src/tqrs/rules/validation.py`:

```python
class ValidationDetector:
    """Detect validation patterns in ticket description."""

    # Validation method patterns
    OKTA_PATTERNS = [
        r"okta\s*(push|mfa)",
        r"validated\s*by[:\s]*okta",
        r"okta\s*verification",
    ]

    PHONE_VALIDATION_PATTERNS = [
        r"validated\s*by[:\s]*(employee\s*id|emp\s*id|full\s*name)",
        r"(name|employee\s*id|location)\s*(verified|confirmed|validated)",
    ]

    GUEST_CHAT_PATTERNS = [
        r"guest\s*chat",
        r"guest\s*validation",
    ]

    # Required validation elements
    REQUIRED_ELEMENTS = ["name", "employee_id", "location"]

    def evaluate(self, ticket: ServiceNowTicket) -> RuleResult:
        """Evaluate validation compliance."""
        contact_type = ticket.contact_type.lower()

        if contact_type == "phone":
            return self._evaluate_phone_validation(ticket)
        elif contact_type == "chat":
            return self._evaluate_chat_validation(ticket)
        elif contact_type == "email":
            return self._evaluate_email_validation(ticket)
        else:
            return self._evaluate_self_service(ticket)

    def _evaluate_phone_validation(self, ticket: ServiceNowTicket) -> RuleResult:
        """Phone calls require full validation documented."""
        # Check for validation patterns in description
        # Return PASS if properly documented
        # Return -15 if performed but not documented correctly
        # Return FAIL if validation not performed

    def _has_okta_validation(self, text: str) -> bool:
        """Check for OKTA validation mention."""

    def _has_required_elements(self, text: str) -> dict[str, bool]:
        """Check which validation elements are documented."""
```

Scoring logic:
- PASS: Validation completed and properly documented
- -15: Validation done but documentation incomplete
- N/A: Contact type doesn't require validation (OKTA-verified chat)
- FAIL: Validation not performed

**Verification**:
- [ ] Detects "Validated by: Okta Push MFA & Full Name" → PASS
- [ ] Detects "validated by Employee ID, full name" → PASS
- [ ] Handles missing validation → FAIL
- [ ] Handles partial documentation → -15

---

### Task 4: Critical Process Detector
**Identify critical processes and verify proper handling**

Create `src/tqrs/rules/critical_process.py`:

```python
class CriticalProcessDetector:
    """Detect critical processes and verify compliance."""

    # Critical process types with detection patterns
    CRITICAL_PROCESSES = {
        "password_reset": {
            "patterns": [r"password\s*reset", r"reset\s*password", r"pwd\s*reset"],
            "subcategory": "password reset",
            "required_elements": ["trusted_colleague", "new_password_method"],
        },
        "lost_stolen": {
            "patterns": [r"lost", r"stolen", r"missing\s*device"],
            "required_elements": ["device_details", "escalation"],
        },
        "vip": {
            "patterns": [r"\bvip\b", r"executive"],
            "priority_requirement": "high",
        },
        "virus_malware": {
            "patterns": [r"virus", r"malware", r"infected"],
            "required_elements": ["isolation", "escalation"],
        },
        "data_privacy": {
            "patterns": [r"data\s*privacy", r"security\s*incident", r"breach"],
            "required_elements": ["escalation", "documentation"],
        },
        # ... more critical processes
    }

    def evaluate(self, ticket: ServiceNowTicket) -> RuleResult:
        """Evaluate critical process compliance."""
        detected = self._detect_critical_processes(ticket)

        if not detected:
            return RuleResult(
                criterion_id="critical_process_followed",
                passed=True,
                score="N/A",
                evidence="No critical process detected",
                reasoning="Ticket does not involve a critical process",
            )

        # Check if process was followed correctly
        for process_type in detected:
            result = self._verify_process_compliance(ticket, process_type)
            if not result.passed:
                return result

        return RuleResult(
            criterion_id="critical_process_followed",
            passed=True,
            score="PASS",
            evidence=f"Critical process(es) detected: {detected}",
            reasoning="Required procedures were followed",
        )

    def _detect_critical_processes(self, ticket: ServiceNowTicket) -> list[str]:
        """Detect which critical processes apply to this ticket."""

    def _verify_process_compliance(self, ticket: ServiceNowTicket, process_type: str) -> RuleResult:
        """Verify specific process was followed correctly."""
        # For password reset, check for trusted colleague pattern
        # For VIP, check priority setting
        # etc.
```

Password reset specific checks:
- Trusted colleague documented
- New password sent correctly (not to affected user directly)
- Password change instructions provided

Scoring logic:
- PASS: Critical process followed correctly
- -35: Critical process failure (non-password)
- FAIL: Password process failure (automatic fail)
- N/A: No critical process involved

**Verification**:
- [ ] Detects "password reset" from subcategory and description
- [ ] Verifies trusted colleague pattern for password reset
- [ ] Returns FAIL for password process violations
- [ ] Returns -35 for other critical process failures
- [ ] Returns N/A when no critical process

---

### Task 5: Category Validator
**Basic validation of category/subcategory selections**

Create `src/tqrs/rules/category.py`:

```python
class CategoryValidator:
    """Validate category and subcategory selections."""

    # Known valid categories with their subcategories
    CATEGORY_MAPPING = {
        "software": ["reset_restart", "installation", "configuration", ...],
        "hardware": ["laptop", "desktop", "monitor", "peripherals", ...],
        "inquiry": ["password reset", "account access", "general", ...],
        "network": ["connectivity", "vpn", "wifi", ...],
        # ... more mappings
    }

    def evaluate_category(self, ticket: ServiceNowTicket) -> RuleResult:
        """Evaluate category selection."""
        category = ticket.category.lower()

        # Check if category exists
        if category not in self.CATEGORY_MAPPING:
            return RuleResult(
                score=0,
                reasoning="Unknown category",
                coaching="Use a valid category from the ServiceNow taxonomy",
            )

        # Basic plausibility check against short description
        # Full accuracy assessment deferred to LLM
        return RuleResult(
            score=10,  # Assume correct, LLM will adjust
            reasoning="Category exists in taxonomy",
            coaching=None,
        )

    def evaluate_subcategory(self, ticket: ServiceNowTicket) -> RuleResult:
        """Evaluate subcategory selection."""
        category = ticket.category.lower()
        subcategory = ticket.subcategory.lower()

        if category in self.CATEGORY_MAPPING:
            valid_subs = self.CATEGORY_MAPPING[category]
            if subcategory not in valid_subs:
                return RuleResult(
                    score=5,  # Better available
                    reasoning=f"Subcategory '{subcategory}' not in expected list for '{category}'",
                    coaching="Review subcategory options for this category",
                )

        return RuleResult(
            score=10,
            reasoning="Subcategory matches category",
            coaching=None,
        )
```

Note: Full category accuracy requires LLM assessment in Phase 3. Rules engine provides baseline validation only.

**Verification**:
- [ ] Validates known categories
- [ ] Checks subcategory matches parent category
- [ ] Provides coaching for mismatches

---

### Task 6: Rules Evaluator Orchestrator
**Combine all rules into unified evaluation**

Create `src/tqrs/rules/evaluator.py`:

```python
class RulesEvaluator:
    """Orchestrate all rule-based evaluations."""

    def __init__(self):
        self.short_desc_validator = ShortDescriptionValidator()
        self.validation_detector = ValidationDetector()
        self.critical_process_detector = CriticalProcessDetector()
        self.category_validator = CategoryValidator()

    def evaluate(self, ticket: ServiceNowTicket, template: TemplateType) -> list[RuleResult]:
        """Run all applicable rules for given template."""
        results = []

        # Always evaluate these
        results.append(self.critical_process_detector.evaluate(ticket))
        results.append(self.validation_detector.evaluate(ticket))

        # Template-specific evaluations
        if template == TemplateType.INCIDENT_LOGGING:
            results.append(self.short_desc_validator.validate(ticket))
            results.append(self.category_validator.evaluate_category(ticket))
            results.append(self.category_validator.evaluate_subcategory(ticket))

        elif template == TemplateType.INCIDENT_HANDLING:
            # Handling-specific rules
            pass

        elif template == TemplateType.CUSTOMER_SERVICE:
            # Customer service rules (most deferred to LLM)
            pass

        return results

    def get_rule_scores(self, ticket: ServiceNowTicket, template: TemplateType) -> dict[str, RuleResult]:
        """Get results keyed by criterion_id."""
        results = self.evaluate(ticket, template)
        return {r.criterion_id: r for r in results}
```

**Verification**:
- [ ] Returns results for all applicable rules
- [ ] Template-specific rule selection works
- [ ] Results can be merged with LLM results in Phase 4

---

### Task 7: Tests for Rules Engine
**Comprehensive tests for all rules**

Create `tests/test_rules.py`:

Test cases for Short Description:
- Valid 4-part format with " - " separators
- Valid 4-part format with "-" separators
- Missing LoB
- Missing location
- Missing application
- Invalid/empty brief description

Test cases for Validation:
- Phone call with full OKTA validation
- Phone call with employee ID validation
- Phone call missing validation
- Chat with OKTA verification
- Self-service (no validation needed)

Test cases for Critical Process:
- Password reset with trusted colleague
- Password reset without trusted colleague (FAIL)
- VIP ticket with correct priority
- Lost/stolen device ticket
- No critical process (N/A)

Test cases for Category:
- Valid category and subcategory
- Valid category, invalid subcategory
- Invalid category

Test the evaluator against prototype samples:
- INC8924218: VDI reset (no critical process, phone validation)
- INC8924339: Password reset (critical process, phone validation)
- INC8923651: Password reset (critical process, phone validation)

**Verification**:
- [ ] All rules tests pass
- [ ] Prototype samples evaluate correctly
- [ ] Edge cases handled

---

## Execution Order

```
Task 1 (Module Structure)
    ↓
Task 2 (Short Description) ──┐
Task 3 (Validation) ─────────┼── Can run in parallel after Task 1
Task 4 (Critical Process) ───┤
Task 5 (Category) ───────────┘
    ↓
Task 6 (Evaluator) ←── needs Tasks 2-5
    ↓
Task 7 (Tests) ←── needs all above
```

## Success Criteria

Phase 2 is complete when:

1. **Short Description**: Correctly validates 4-part format with scoring
2. **Validation**: Detects OKTA, phone, guest validation patterns
3. **Critical Process**: Identifies password reset, VIP, lost/stolen with compliance check
4. **Category**: Basic validation against known taxonomy
5. **Evaluator**: Orchestrates all rules per template
6. **Tests**: All prototype samples pass expected rule evaluations
7. **Quality**: `ruff check src/` passes, `pytest tests/` passes

## Estimated Complexity

- **Tasks**: 7
- **New files**: ~8
- **Lines of code**: ~600-800
- **Risk**: Low-Medium (regex patterns need tuning)

## Notes

- Rules provide baseline scores; LLM (Phase 3) can override for accuracy
- Critical process FAIL results in automatic 0 score (implemented in Phase 4)
- Validation -15 is applied as deduction in Phase 4
- Category/subcategory full accuracy deferred to LLM evaluation
- Pattern matching may need iteration based on real ticket data
